from __future__ import annotations
from dataclasses import dataclass
from typing import Optional
import enum
import logging
import os

from inotify.constants import *  # type: ignore
import inotify.adapters  # type: ignore


class WatcherEventType(enum.Enum):
    NEW_OR_CHANGED = enum.auto()
    GONE = enum.auto()
    UNKNOWN = enum.auto()

    @staticmethod
    def from_inotify_type_names(tn: 'list[str]') -> WatcherEventType:
        if 'IN_CREATE' in tn or 'IN_MOVED_TO' in tn or 'IN_CLOSE_WRITE' in tn:
            return WatcherEventType.NEW_OR_CHANGED
        elif 'IN_DELETE' in tn or 'IN_MOVED_FROM' in tn:
            return WatcherEventType.GONE
        else:
            return WatcherEventType.UNKNOWN


@dataclass
class WatcherEvent(object):
    """
    Represents a change regarding a project directory or schema file.

    Note that `schema_file` will be `None` for events concerning only a
    directory, but such events may still imply that a containing schema file has
    been deleted or moved.
    """
    event_type: WatcherEventType
    project_dir: str
    schema_file: Optional[str]

    @staticmethod
    def from_inotify(
        type_names: 'list[str]',
        project_dir: str,
        schema_file: Optional[str]
    ) -> WatcherEvent:
        """
        Convenience method to construct an event with its type inferred from a
        list of inotify event types.
        """
        event_type = WatcherEventType.from_inotify_type_names(type_names)
        return WatcherEvent(event_type, project_dir, schema_file)

    @staticmethod
    def new_or_changed(project_dir: str, schema_file: str) -> WatcherEvent:
        """
        Convenience method to construct a `NEW_OR_CHANGED` event. This type of
        event must always have a value for `schema_file`.
        """
        return WatcherEvent(
            WatcherEventType.NEW_OR_CHANGED, project_dir, schema_file
        )

    @staticmethod
    def project_dir_gone(project_dir: str) -> WatcherEvent:
        """
        Convenience method to construct a `GONE` event regarding a project
        directory.
        """
        return WatcherEvent(WatcherEventType.GONE, project_dir, None)

    def is_new_or_changed(self) -> bool:
        return self.event_type == WatcherEventType.NEW_OR_CHANGED

    def is_gone(self) -> bool:
        return self.event_type == WatcherEventType.GONE

    def is_unknown(self) -> bool:
        return self.event_type == WatcherEventType.UNKNOWN

    def schema_file_path(self) -> str:
        if not self.schema_file:
            raise ValueError(
                "tried to get file path from an event without a file"
            )
        return os.path.join(self.project_dir, self.schema_file)


class SchemaFileWatcher(object):
    """
    This is a wrapper around inotify that emits change events for project schema
    files in a project directory.

    A root watch is established on the given `projects_root` directory; any
    subdirectories in `projects_root` will be monitored for files matching the
    `schema_file`. If any such files are created, edited, deleted, or moved,
    `SchemaFileWatcher` will emit an event. Each schema file that already exists
    when the watcher is started will also generate an event so initial
    configuration can be done through the same API.

    The emitted event types are:
        - 'update' when schema files are created, edited, or renamed
        - 'remove' when schema files are deleted or renamed

    You'll notice that schema files being renamed emit both an 'update' and a
    'remove' event. This is due to the way the inotify API works. Renaming a
    file causes two events: an IN_MOVED_FROM with the source path that was
    renamed, and an IN_MOVED_TO with the new location of our file. The simplest
    way for us to handle this case is to consider file moves as a pair of
    'remove' and 'update', which is not worth optimizing as long as web server
    reconfiguration is cheap.
    """

    PROJECT_ROOT_MASK = (
        IN_ISDIR | IN_MOVE | IN_CREATE | IN_DELETE | IN_DELETE_SELF | IN_MOVE_SELF  # type: ignore
    )

    PROJECT_DIR_MASK = (
        IN_CREATE | IN_DELETE | IN_CLOSE_WRITE | IN_MOVE  # type: ignore
    )

    _projects_root: str
    _schema_file: str
    _inotify: inotify.adapters.Inotify
    _buffered_events: 'list[WatcherEvent]'

    def __init__(self, projects_root: str, schema_file: str) -> None:
        """
        Create a new schema file watcher.

        A note on the use of `_buffered_events`:
        During normal operation after startup, no more than one event should
        ever be buffered. The only purpose of this buffer is holding events
        generated by the constructor when initially scanning for schema files;
        there's no generator-idiomatic way for the constructor to return those
        events, so they're buffered and returned by this method instead. Since
        we already have this buffer and the logic to return events from it, it's
        simpler to push new events to this buffer as well instead of adding
        extra return logic.
        """
        self._projects_root = projects_root
        self._schema_file = schema_file

        self._inotify = inotify.adapters.Inotify()
        self._inotify.add_watch(self._projects_root, mask=self.PROJECT_ROOT_MASK)

        self._buffered_events = []

        # add watches to project dirs existing at startup
        with os.scandir(self._projects_root) as it:
            for entry in it:
                if entry.name.startswith('.') or not entry.is_dir():
                    continue
                self._add_project_dir_watch(entry.path)

    def __iter__(self) -> SchemaFileWatcher:
        return self

    def __next__(self) -> WatcherEvent:  # type: ignore[return]
        """
        Yield the next event.

        See `__init__` for an explanation of `_buffered_events`.
        """
        if self._buffered_events:
            logging.debug("returning buffered event before wait")
            return self._buffered_events.pop(0)

        logging.debug("waiting...")
        for e in self._inotify.event_gen(yield_nones=False):
            (_, type_names, path, filename) = e
            logging.debug(f"[type_names={type_names} path={path} filename={filename}]")

            full_path = os.path.join(path, filename)

            if path == self._projects_root:
                project_dir = full_path

                e = WatcherEvent.from_inotify(type_names, project_dir, None)

                if e.is_new_or_changed():
                    self._add_project_dir_watch(project_dir)
                else:
                    self._remove_project_dir_watch(project_dir)

            elif filename == self._schema_file:
                # `path` is probably a child of `_projects_root`
                project_dir = path
                schema_file = full_path

                e = WatcherEvent.from_inotify(type_names, project_dir, schema_file)

                if not e.is_unknown():
                    self._buffered_events.append(e)

            if self._buffered_events:
                logging.debug("returning buffered event after wait")
                return self._buffered_events.pop(0)

    def _add_project_dir_watch(self, project_dir: str) -> None:
        self._inotify.add_watch(project_dir, self.PROJECT_DIR_MASK)

        schema_file = os.path.join(project_dir, self._schema_file)

        if os.path.isfile(schema_file) or os.path.islink(schema_file):
            logging.debug(f"{project_dir}: has a schema file")

            e = WatcherEvent.new_or_changed(project_dir, schema_file)
            self._buffered_events.append(e)

    def _remove_project_dir_watch(self, project_dir: str) -> None:
        self._inotify.remove_watch(project_dir)

        e = WatcherEvent.project_dir_gone(project_dir)
        self._buffered_events.append(e)
